#pragma config(Sensor, S1,     touch,        sensorTouch)
#pragma config(Sensor, S2,     gyro,         sensorI2CHiTechnicGyro)
#pragma config(Sensor, S3,     color,         sensorCOLORFULL)
#pragma config(Sensor, S4,     sonar,         sensorSONAR)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const tSensors kGyroSensor = S2;
const float cAngle = (130.0/90.0);
//#include "GyroDriver.c"

//float fOldAngle = fGyroAngle;

void ClearMotorA(){
	motor[motorA] = 0;
	nMotorEncoder[motorA] = 0;
  nMotorEncoderTarget[motorA] =0;
}

void ClearMotorB(){
	motor[motorB] = 0;
	nMotorEncoder[motorB] = 0;
  nMotorEncoderTarget[motorB] =0;
}

void ClearMotorC(){
	motor[motorC] = 0;
	nMotorEncoder[motorC] = 0;
  nMotorEncoderTarget[motorC] =0;
}
/*
void Left(int angle,float speed)
{

fOldAngle = fGyroAngle;
  float fAngle = angle * cAngle;
	ClearMotorB();
	ClearMotorC();
	// Motor B is master , C is slave
  nSyncedMotors = synchBC ;
  // Motor C rotates at the same speed as motor B, but reversed
  nSyncedTurnRatio = -100;
	motor[motorB] = speed;
  while ((fGyroAngle)>(-1*fAngle)){
    nMotorEncoderTarget[motorB] = nMotorEncoder[motorB]+1;
  }
  motor[motorB] = 0;
  nSyncedMotors=synchNone;
}

void Right(int angle,int speed)
{
  fOldAngle = fGyroAngle;
  float fAngle = angle * cAngle;
	ClearMotorB();
	ClearMotorC();
	// Motor B is master , C is slave
  nSyncedMotors = synchBC ;
  // Motor C rotates at the same speed as motor B, but reversed
  nSyncedTurnRatio = -100;
	motor[motorB] = -1*speed;
  while ((fGyroAngle)<(fAngle+fOldAngle)){
    nMotorEncoderTarget[motorB] = nMotorEncoder[motorB]-1;
  }
  motor[motorB] = 0;
  nSyncedMotors=synchNone;
}
*/
void MoveForward(int delay,int speed){
	ClearMotorB();
	ClearMotorC();
	// Motor B is master , C is slave
  nSyncedMotors = synchBC ;
  // Motor C rotates at the same speed as motor B
  nSyncedTurnRatio = 100;
	motor[motorB] = speed;
	//motor[motorC] = speed;
	wait1Msec(delay);
	nSyncedMotors=synchNone;
	ClearMotorB();
	ClearMotorC();
}

void MoveBack(int delay,int speed){
	ClearMotorB();
	ClearMotorC();
	// Motor B is master , C is slave
  nSyncedMotors = synchBC ;
  // Motor C rotates at the same speed as motor B
  nSyncedTurnRatio = 100;
	motor[motorB] = -1*speed;
	//motor[motorC] = -1*speed;
	wait1Msec(delay);
	nSyncedMotors=synchNone;
	ClearMotorB();
	ClearMotorC();
}

void MoveUp(int speed)
{
	ClearMotorA();
  motor[motorA] = speed;
	while(SensorValue(touch) == 0){
	//	nMotorEncoderTarget[motorA] = nMotorEncoder[motorA]+1;
	}
	wait1Msec(500);
	ClearMotorA();
}

void MoveDown(int speed)
{
int dest=0;
int p=0;
int i=SensorValue[sonar];
ClearMotorA();
	motor[motorA] = -1*speed;
	while(SensorValue(sonar)>10){

	nMotorEncoderTarget[motorA] = nMotorEncoder[motorA]-1;
    wait1Msec(100);

    	dest=SensorValue[sonar];


	nxtDisplayTextLine(1, "%d", dest);/*
p=abs(SensorValue(sonarSensor)-i);
nxcase GREENCOLOR:    nxtDisplayTextLine(1, "Green");break;tDisplayTextLine(3, "%d", p);
*/
}


//	PlaySound ( soundException );
	ClearMotorA();

	i = nMotorEncoder[motorA];
 motor[motorA] = -1*speed;
  while(abs(nMotorEncoder[motorA]-i)<150){
//	nMotorEncoderTarget[motorA] = nMotorEncoder[motorA]-1;

  //dest=abs(nMotorEncoder[motorA]-i;
//nxtDisplayTextLine(1, "%d", dest);
	}
  ClearMotorA();	dest=abs(nMotorEncoder[motorA]-i);
//nxtDisplayTextLine(1, "%d", dest);

//  PlaySound ( soundBeepBeep );

}

/*==================================================================*/


task main()
{
	int degreesToTurn = 180;
	float degreesSoFar = 0;
	int initialTurnReading = SensorValue[gyro];

	nSyncedMotors = synchBC;
	nSyncedTurnRatio = -100;
	motor[motorB] = -30;
	while (true){
	  wait1Msec(10);int p = SensorValue[gyro];
	//  if (abs(SensorValue[gyro] - initialTurnReading)>2) {

	  int currentGyroReading = SensorValue[gyro] - initialTurnReading;
	  degreesSoFar = degreesSoFar + currentGyroReading*.01;
//	}
	  if (abs(degreesSoFar) >= degreesToTurn) motor[motorB] = 0;
}

  motor[motorB] = 0;


}
