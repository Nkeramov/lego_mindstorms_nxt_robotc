#pragma config(Sensor, S1,     touch,          sensorTouch)
#pragma config(Sensor, S2,     gyro,           sensorI2CHiTechnicGyro)
#pragma config(Sensor, S3,     color,          sensorColorNxtFULL)
#pragma config(Sensor, S4,     sonar,          sensorSONAR)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//HiTechnic 	#pragma config(Sensor, S2,     gyro,           sensorI2CHiTechnicGyro)

//MSIMU  #pragma config(Sensor, S2,     gyro,           sensorI2CCustomFastSkipStates)

//#define MindSensors_IMU
#define HiTechnic_Gyro
#define maxVelocity 50

const int move_points = 3; //5

const float kMove = 0.02842;
//0.037 - wheels
//0.029 - caterpillars
//0.02842	printed
//0.03944 new

ubyte bstate[6] = {0,0,0,0,1,0};
int kold=0, knew=0;
bool claw=true, clawState=false;
float curx=0, cury=0;

#ifdef HiTechnic_Gyro
	#include "HiTechnic_new_gyroDriver.c"
#endif

#ifdef MindSensors_IMU
	#include "MindSensors_imu.h"
	#include "MindSensors_gyroDriver.c"
#endif

#include "drawBTlogo.c"

TNxtButtons new_btn = kNoButton;
TNxtButtons old_btn = kNoButton;
TColors new_color = BLACKCOLOR;
TColors old_color = BLACKCOLOR;
int new_dest = 0;
int old_dest = 0;
int OXAngle=90;

void MoveFwd(short speed=30){
	nSyncedTurnRatio = 100;
	nSyncedMotors = synchBC;
	motor[motorB] = speed;
}

void Turn(short speed=50){
	nSyncedMotors = synchBC;
	nSyncedTurnRatio = -100;
	motor[motorB] = speed;
}

void FwdLeft(short speed=50){
	nSyncedMotors = synchBC;
	nSyncedTurnRatio = 75;
	motor[motorB] = speed;
}

void FwdRight(short speed=50){
	nSyncedMotors = synchCB;
	nSyncedTurnRatio = 75;
	motor[motorC] = speed;
}

void Shell_sort(int *a){
	int d=2;
	int i=0;
	int t=0;
	while (d>0){
		for (i=0; i<5-d; i++){
      int j=i;
			while (a[j]>a[j+d] && j>=0) {
				t=a[j+d];
				a[j+d]=a[j];
				a[j]=t;
				j--;
			}
		}
		d=d/2;
		}
}

int GetDistance(void){
	int a[5], r=0;
	for (int i=0; i<5; i++){
		a[i]=SensorValue[sonar];
		wait1Msec(1);
	}
	Shell_sort(a);
	r=a[3];
	if (r>=25) r+=3;
	return r;
}

void ResetMotor(tMotor mname){
	motor[mname] = 0;
	nMotorEncoder[mname] = 0;
	nMotorEncoderTarget[mname] = 0;
	if (mname != motorA) nSyncedMotors = synchNone;
}

void MoveStraight(int dist, short speed=40){
	if (dist<0) speed = -abs(speed);
	dist = abs(dist);
	ResetMotor(motorB);
	ResetMotor(motorC);
	nSyncedMotors = synchBC;
	nSyncedTurnRatio = 100;
	motor[motorB] = speed;
	while (abs(nMotorEncoder[motorB])*kMove<dist);
	curx+=sgn(speed)*dist*cosDegrees(OXAngle);
	cury+=sgn(speed)*dist*sinDegrees(OXAngle);
	ResetMotor(motorB);
	ResetMotor(motorC);
}

task Claw {
	while (true){
		if (claw && !clawState) {
			ResetMotor(motorA);
			motor[motorA] = 40;
			waitUntil(SensorValue[touch]);
			ResetMotor(motorA);
			wait1Msec(250);
			motor[motorA] = 15;
			clawState=true;
		}
		if (!claw && clawState){
			ResetMotor(motorA);
			motor[motorA] = 40;
			waitUntil(SensorValue[touch]);
			ResetMotor(motorA);
			motor[motorA] = -30;
			waitUntil(abs(nMotorEncoder[motorA]) >= 600);
			ResetMotor(motorA);
			clawState=false;
		}
	}
	wait1Msec(250);
}

void Rotate(float angle = 180, short speed=20){
	ResetMotor(motorB);
	ResetMotor(motorC);
	OXAngle-=angle;
	speed=abs(speed);
	if (angle>0) speed*=-1;
	angle = abs(angle);
	gyroAngle = 0;
	nSyncedMotors = synchBC;
	nSyncedTurnRatio = -100;
	motor[motorB] = speed;
	if (angle>15) {
		while (abs(gyroAngle) < angle-15); //15
		motor[motorB] = speed*2/3;
	}
	else motor[motorB]=speed*2/3;
	while (abs(gyroAngle) < angle);
	ResetMotor(motorB);
	ResetMotor(motorC);
}

void SearchAngle(int *ang, int *dist, int angle_max = 90, short speed = 10){
	angle_max = abs(angle_max)%360;
	speed = abs(speed);
	int angle_min = 0;
	int dist_new = 0;
	int dist_min = 255;
	int angle_old = 0;
	Rotate(-angle_max,speed);
	wait1Msec(300);
	gyroAngle = -angle_max;
	nSyncedMotors = synchBC;
	nSyncedTurnRatio = -100;
	motor[motorB] = -speed;
	while (gyroAngle<angle_max){
		dist_new = GetDistance();
		if (dist_new < dist_min) {
			dist_min = dist_new;
			angle_min = ceil(gyroAngle + angle_old);
		}
	}
	ResetMotor(motorB);
	ResetMotor(motorC);
	wait1Msec(300);
	Rotate(ceil(-gyroAngle), speed);
	*ang = angle_min;
	//distance from claw (color sensor) to backward of sonar
	*dist = dist_min-10;
}

void TestSnatcher(){
	eraseDisplay();
	displayBigStringAt(14, 55, "TESTING");
	MoveStraight(15,50);
	wait1Msec(1000);
	MoveStraight(-15,50);
	wait1Msec(1000);
	Rotate(180,30);
	wait1Msec(1000);
	Rotate(-180,30);
	wait1Msec(1000);
	claw=true;
	while(!SensorValue[touch]);
	wait1Msec(1000);
	claw=false;
	playSound(soundBeepBeep);
	claw=true;
	while(!SensorValue[touch]);
	Rotate(45,30);
	wait1Msec(1000);
	Rotate(-90,30);
	wait1Msec(1000);
	Rotate(45,30);
	claw=false;
}

short SelectProgram(void){
	short selProg = -1;
	short curProg = 0;
	bool exit = false;
	// double clicking EXIT button will terminate program
	nNxtExitClicks  = 2;
	eraseDisplay();
	displayCenteredBigTextLine(0,"SELECT");
	displayCenteredBigTextLine(2,"PROGRAM");
	displayCenteredBigTextLine(4,"%d",curProg);
	displayCenteredTextLine(6,"test motors");
	displayCenteredTextLine(7,"and claw");
	// selecting program
	while (selProg < 0){
		// wait for button press
		while (nNxtButtonPressed == kNoButton);
		new_btn = nNxtButtonPressed;
		playSound(soundBlip);
		switch (new_btn){
			case kLeftButton: curProg--; if (curProg < 0) curProg = 12;	break;
			case kRightButton:	curProg++; if (curProg > 12) curProg = 0;	break;
			case kEnterButton:	selProg = curProg; break;
			case kExitButton:	 exit = true;  break;
		}
		if (exit){
			eraseDisplay();
			displayCenteredBigTextLine(0,"FOR EXIT");
			displayCenteredBigTextLine(2,"PRESS");
			displayCenteredBigTextLine(4,"AGAIN");
			wait1Msec(1000);
			exit = false;
		}
		eraseDisplay();
		displayCenteredBigTextLine(0,"SELECT");
		displayCenteredBigTextLine(2,"PROGRAM");
		displayCenteredBigTextLine(4,"%d",curProg);
		switch (curProg){
		case 0:
			displayCenteredTextLine(6,"test motors");
			displayCenteredTextLine(7,"and claw");
			break;
		case 1:
			displayCenteredTextLine(6,"find and catch");
			displayCenteredTextLine(7,"nearest object");
			break;
		case 2:
			displayCenteredTextLine(6,"random moving");
			displayCenteredTextLine(7,"and returning");
			break;
		case 3:
			displayCenteredTextLine(6,"wall");
			displayCenteredTextLine(7,"avoidance");
			break;
		case 4:
			displayCenteredTextLine(6,"select green");
			displayCenteredTextLine(7,"and blue colors");
			break;
		case 5:
			displayCenteredTextLine(6,"view sonar");
			displayCenteredTextLine(7,"sensor");
			break;
		case 6:
			displayCenteredTextLine(6,"view gyro");
			displayCenteredTextLine(7,"sensor");
			break;
		case 7:
			displayCenteredTextLine(6,"view color");
			displayCenteredTextLine(7,"sensor");
			break;
		case 8:
			displayCenteredTextLine(6,"play all");
			displayCenteredTextLine(7,"sounds");
			break;
		case 9:
			displayCenteredTextLine(6,"view pressed");
			displayCenteredTextLine(7,"button");
			break;
		case 10:
			displayCenteredTextLine(6,"manual");
			displayCenteredTextLine(7,"control");
			break;
		case 11:
			displayCenteredTextLine(6,"Slave");
			break;
		case 12:
			displayCenteredTextLine(6,"find and catch");
			displayCenteredTextLine(7,"everything");
			break;
		}
		// wait for button release
		while (nNxtButtonPressed != kNoButton);
	}
	// program selected go to perform it
	eraseDisplay();
	displayCenteredBigTextLine(2,"SELECTED");
	displayCenteredBigTextLine(4,"%d",selProg);
	wait1Msec(1000);
	eraseDisplay();
	return selProg;
}

void InitSnatcher(){
	eraseDisplay();
	//drawing logo
	displayCenteredBigTextLine(0,"LEGO");
	displayCenteredBigTextLine(2,"SNATCHER");
	wait1Msec(250);
	// this code already in driver
	//SensorType[gyro] = sensorLightInactive;
	eraseDisplay();
	startTask(Claw);
	displayCenteredBigTextLine(0,"LEGO");
	displayCenteredBigTextLine(2,"SNATCHER");
	displayCenteredBigTextLine(4,"InitGyro");
	playSound (soundBeepBeep);
	wait1Msec(500);
	// initing gyro
	while (!gyroState);
	playSound (soundBeepBeep);
}

short ColorCheque(void){
	short n=0;
	switch (SensorValue[color]) {
					case BLACKCOLOR:  n=1; break;
					case BLUECOLOR:   n=2; break;
					case GREENCOLOR:  n=3; break;
					case YELLOWCOLOR: n=4; break;
					case REDCOLOR:    n=5; break;
					case WHITECOLOR:  n=6; break;
					default:          n=0; break;
	}
	return n;
}

//r+  l-  OX Reversed
void MoveTo(float x, float y, bool boolean=false){
	float dx=curx-x, dy=cury-y;
	int length=sqrt(dx*dx+dy*dy);
	if (boolean) length-=10;
	int delta = OXAngle;
	if (dx < 0)
			delta -= radiansToDegrees(atan(dy/dx));
		else if (dx > 0)
			delta -= radiansToDegrees(atan(dy/dx)) + 180;
		else
			delta += sgn(dy)*90;
		delta = delta % 360;
		if (abs(delta)>180)
			delta -= sgn(delta)*360;
		Rotate(delta);
		wait1Msec(300);
		MoveStraight(length, 30);

		/*
		OLD RETURNING

		if (dx < 0)
			delta -= radiansToDegrees(atan(dy/dx));
		else if (dx > 0)
			delta -= radiansToDegrees(atan(dy/dx)) + 180;
		else
			delta += (dy/abs(dy))*90;
		delta = delta % 360;
		if (abs(delta)>180)
			delta -= sgn(delta)*360;
		Rotate(delta);
		ang -= delta;
		wait1Msec(300);
		MoveStraight(ceil(sqrt(dx*dx+dy*dy)));
		wait1Msec(300);
		delta=(ang-90)%360;
		ang -= delta;
		if (abs(delta)>180) delta -= sgn(delta)*360;
		Rotate(delta);
		displayTextLine(3, "angle  %d", ang);*/
}

task main(){
	setSessionPIN("1234");
	wait1Msec(1000);
	claw=true;
	float fOldAngle = -1;
	InitSnatcher();
	int numberProgram = SelectProgram();
	switch (numberProgram){
	case 0: //self-test code
		TNxtButtons new_btnTest= kNoButton;
		bool test = true;
		while(test == true){
			TestSnatcher();
			eraseDisplay();
			displayCenteredBigTextLine(2,"REPEAT");
			displayCenteredBigTextLine(4,"TEST?");
			displayCenteredTextLine(6,"PRESS");
			displayCenteredTextLine(7,"ENTER/EXIT");
			while (nNxtButtonPressed == kNoButton){}
			new_btnTest = nNxtButtonPressed;
			if (new_btnTest == kExitButton) test = false;
		}
		break;
	case 1: //searching objects
		claw=true;
		wait1Msec(100);
		while(!SensorValue[touch]);
		int Angle = 0;
		int Distance = 0;
		SearchAngle(&Angle, &Distance, 90, 20);
		eraseDisplay();
		displayTextLine(0, "Angle %d", Angle);
		displayTextLine(2, "Distance %d", Distance);
		wait1Msec(300);
		Rotate(Angle);
		claw=false;
		waitUntil(!clawState);
		MoveStraight(Distance,50);
		claw=true;
		waitUntil(SensorValue[touch]);
		switch (ColorCheque()){

			case  1: displayCenteredBigTextLine(4, "Black"); playSoundFile("black.rso"); break;
			case  2:	displayCenteredBigTextLine(4, "Blue"); playSoundFile("blue.rso"); break;
			case  3:	displayCenteredBigTextLine(4, "Green"); playSoundFile("green.rso"); break;
			case  4: displayCenteredBigTextLine(4, "Yellow"); playSoundFile("yellow.rso"); break;
			case  5: displayCenteredBigTextLine(4, "Red"); playSoundFile("red.rso"); break;
			case  6: displayCenteredBigTextLine(4, "White"); playSoundFile("white.rso"); break;
			default: displayCenteredBigTextLine(4, "Undefined"); break;
		}
		break;
	case 2: //moving and returning
		claw=true;
		while(!SensorValue[touch]);
		float dx = 0;
		float dy = 0;
		int dist, delta;
		//int ang = 90;
		for(short i = 0; i < move_points; i++){
			delta = (random(8) - 4) * 45;
			//ang -= delta;
			Rotate(delta);
			wait1Msec(300);
			dist = (random(8)+1)*10;
			MoveStraight(dist);
			//dx += cos(degreesToRadians(ang))*dist;
			//dy += sin(degreesToRadians(ang))*dist;
			dx += cosDegrees(OXAngle)*dist;
			dy += sinDegrees(OXAngle)*dist;
			eraseDisplay();
			displayTextLine(0, "angle= %d", OXAngle);
			displayTextLine(1, "dx=  %.3f", dx);
			displayTextLine(2, "dy=  %.3f", dy);
			wait1Msec(300);
		}
		wait1Msec(5000);

		MoveTo(0, 0);
		delta=(OXAngle-90)%360;
		if (abs(delta)>180) delta -= sgn(delta)*360;
		Rotate(delta);

		break;
	case 3:// code for wall avoidance
		claw=true;
		while(!SensorValue[touch]);
		MoveStraight(50,50);
		while (true){
			//new_dest = SensorValue[sonar];
			new_dest = GetDistance();
			if (abs(new_dest-old_dest)>10) eraseDisplay();
			displayBigStringAt(0, 60, "Distance");
			displayBigStringAt(0, 40, "%d cm", new_dest);
			old_dest = new_dest;
			if (new_dest<30) {
				playSound (soundBeepBeep);
				Rotate(180,50);
				MoveStraight(50,50);
			}
		}
		break;
	case 4:// code for selecting only green and blue balls
		claw=false;
		while (true){
			new_color = SensorValue[color];
			if ((new_color == GREENCOLOR) || (new_color == BLUECOLOR)){
				playSound (soundBeepBeep);
				claw=true;
				wait1Msec(3000);
				claw=false;
				wait1Msec(3000);
			}
		}
		break;
	case 5: //code for viewing sonar
		claw=true;
		while(!SensorValue[touch]);
		old_dest = 0;
		while (true){
			new_dest=GetDistance();
			//new_dest = SensorValue[sonar];
			if (new_dest != old_dest){
				eraseDisplay();
				displayCenteredBigTextLine(0, "View");
				displayCenteredBigTextLine(2, "distance");
				displayCenteredBigTextLine(4, "%d cm", new_dest);
				old_dest = new_dest;
			}
			wait1Msec(5);
		}
		break;
	case 6: //code for viewing gyro
		fOldAngle = -100;
		while(true){
			if (gyroAngle != fOldAngle){
				eraseDisplay();
				displayCenteredBigTextLine(0, "View");
				displayCenteredBigTextLine(2, "angle");
				displayCenteredBigTextLine(4, "%.3f", gyroAngle);
				displayCenteredBigTextLine(6, "%d", OXAngle);
				fOldAngle = gyroAngle;
			}
			wait1Msec(5);
		}
		break;
	case 7:// code for viewing color
		old_color = REDCOLOR;
		claw=false;
		wait1Msec(1000);
		while (true){
			new_color = SensorValue[color];
			if (new_color != old_color){
				eraseDisplay();
				displayCenteredBigTextLine(0, "View");
				displayCenteredBigTextLine(2, "color");
				switch (ColorCheque()){
					case  1: displayCenteredBigTextLine(4, "Black"); break;
					case  2:	displayCenteredBigTextLine(4, "Blue"); playSoundFile("blue.rso"); break;
					case  3:	displayCenteredBigTextLine(4, "Green"); playSoundFile("green.rso"); break;
					case  4: displayCenteredBigTextLine(4, "Yellow"); playSoundFile("yellow.rso"); break;
					case  5: displayCenteredBigTextLine(4, "Red"); playSoundFile("red.rso"); break;
					case  6: displayCenteredBigTextLine(4, "White"); playSoundFile("white.rso"); break;
					default: displayCenteredBigTextLine(4, "Undefined"); break;
	}

				old_color = new_color;
			}
			wait1Msec(5);
		}
		break;
	case 8: // code for playing all sounds
		int nSoundIndex;
		while (true){
			for (nSoundIndex = 0; nSoundIndex <= 113; ++nSoundIndex){
				displayCenteredBigTextLine(3, "%d", nSoundIndex);
				playSound((TSounds) nSoundIndex);
				if (bSoundActive){
					while (bSoundActive);
					wait1Msec(500);
				}
			}
		}
		break;
	case 9: // code for viewing pressed button
		nNxtExitClicks  = 3; // Triple clicking EXIT button will terminate program
		eraseDisplay();
		displayCenteredBigTextLine(0,"View");
		displayCenteredBigTextLine(2,"buttons");
		displayCenteredBigTextLine(4,"Nobutton");
		short exit = -1, count=0;
		while (true){
			// wait for button press
			while (nNxtButtonPressed == kNoButton);
			new_btn = nNxtButtonPressed;
			if (new_btn != old_btn){
				eraseDisplay();
				displayCenteredBigTextLine(0,"View");
				displayCenteredBigTextLine(2,"buttons");
				switch (new_btn){
				case kLeftButton:	  displayCenteredBigTextLine(4, "Left"); count++; break;
				case kRightButton:	displayCenteredBigTextLine(4, "Right"); count++; break;
				case kEnterButton:	displayCenteredBigTextLine(4, "Enter"); count ++; break;
				case kExitButton:	  displayCenteredBigTextLine(4, "Exit"); exit++; count=0; break;
				default:            displayCenteredBigTextLine(4, "Nobutton"); count++; break;
				}
			if (count > 1) exit=-1;
			if (exit==1) {
			eraseDisplay();
			displayCenteredBigTextLine(0,"FOR EXIT");
			displayCenteredBigTextLine(2,"PRESS");
			displayCenteredBigTextLine(4,"AGAIN");
			wait1Msec(2000);
			exit = -1;
			}
			}
			// wait for button release
			while (nNxtButtonPressed != kNoButton);
		}
		break;
	case 10: // code for master mode
		claw=true;
		eraseDisplay();
		btDisconnectAll();
		wait1Msec(1000);
		btConnect(3, "Snatcher");
		while (nBTCurrentStreamIndex==-1);
		wait1Msec(1000);
		btConnect(1, "RemoteJ");
/*	TFileIOResult status = nBluetoothCmdStatus;
		while (! (status != ioRsltSuccess) && (status != ioRsltCommPending) )
			status = nBluetoothCmdStatus;
*/
		wait1Msec(5000);
		playSoundFile("link.rso");
		drawBTlogo(1);
		while(true){
			cCmdMessageWriteToBluetooth(1, bstate, 6, mailbox1);
			wait1Msec(10);
			cCmdMessageRead(bstate,5,mailbox2);

			if (bstate[4] && !clawState) {claw=true; bstate[5]=ColorCheque(); cCmdMessageWriteToBluetooth(3,bstate,5,mailbox3);}
			if (!bstate[4] && clawState) {claw=false; cCmdMessageWriteToBluetooth(3,bstate,5,mailbox3);}
			if (bstate[1] && !bstate[3] && !bstate[2]) knew=1;
			if (bstate[0] && !bstate[3] && !bstate[2]) knew=2;
			if (bstate[2] && !bstate[0] && !bstate[1]) knew=3;
			if (bstate[3] && !bstate[0] && !bstate[1]) knew=4;
			if (bstate[2] && bstate[0]) knew=5;
			if (bstate[2] && bstate[1]) knew=6;
			if (bstate[3] && bstate[0]) knew=7;
			if (bstate[3] && bstate[1]) knew=8;
			if (!(bstate[0] || bstate[1] || bstate[2] || bstate[3])) knew=0;

			if (kold!=knew){
				cCmdMessageWriteToBluetooth(3,bstate,5,mailbox3);
				//motor[motorB]=motor[motorC]=0;
				switch (knew) {
					case 1: Turn(-50); break;
					case 2: Turn(50); break;
					case 3: MoveFwd(maxVelocity); break;
					case 4: MoveFwd(-maxVelocity); break;
					case 5: FwdLeft(50); break;
					case 6: FwdRight(50); break;
					case 7: FwdLeft(-50); break;
					case 8: FwdRight(-50); break;
					default: ResetMotor(motorB); ResetMotor(motorC);
				}
				kold=knew;
			}
		}
		break;
		case 11: // code for slave mode
		claw=true;
		eraseDisplay();
		waitUntil(nBTCurrentStreamIndex==0);
		drawBTlogo(2);
		playSoundFile("link.rso");
		while(true){
			cCmdMessageRead(bstate, 5, mailbox3);
			wait1Msec(10);
			if (bstate[4] && !clawState) claw=true;
			if (!bstate[4] && clawState) claw=false;
			if (bstate[1] && !bstate[3] && !bstate[2]) knew=1;
			if (bstate[0] && !bstate[3] && !bstate[2]) knew=2;
			if (bstate[2] && !bstate[0] && !bstate[1]) knew=3;
			if (bstate[3] && !bstate[0] && !bstate[1]) knew=4;
			if (bstate[2] && bstate[0]) knew=5;
			if (bstate[2] && bstate[1]) knew=6;
			if (bstate[3] && bstate[0]) knew=7;
			if (bstate[3] && bstate[1]) knew=8;
			if (!(bstate[0] || bstate[1] || bstate[2] || bstate[3])) knew=0;

			if (kold!=knew){
				motor[motorB]=motor[motorC]=0;
				switch (knew) {
					case 1: Turn(-50); break;
					case 2: Turn(50); break;
					case 3: MoveFwd(maxVelocity); break;
					case 4: MoveFwd(-maxVelocity); break;
					case 5: FwdLeft(50); break;
					case 6: FwdRight(50); break;
					case 7: FwdLeft(-50); break;
					case 8: FwdRight(-50); break;
					default: motor[motorB]=motor[motorC]=0;
				}
				kold=knew;
			}
		}
		break;
		case 12: //catch everything
			claw=true;
			while(!SensorValue[touch]);
			int angle_old=0;
			short speed=10;
			int dist_new=300;
			Rotate(-90,speed);
			wait1Msec(300);
			gyroAngle = -90;
			nSyncedMotors = synchBC;
			nSyncedTurnRatio = -100;
			while (gyroAngle<90){
				motor[motorB] = -speed;
				dist_new=GetDistance();
				OXAngle=90-gyroAngle;
				if (dist_new<100 && dist_new>10) {
					wait1Msec(200);
					ResetMotor(motorB);
					ResetMotor(motorC);
					angle_old=gyroAngle;
					OXAngle=90-gyroAngle;
					claw=false;
					waitUntil(!clawState);
					MoveStraight(dist_new-12);
					claw=true;
					while(!SensorValue[touch]);
					MoveTo(0, 0);
					claw=false;
					waitUntil(!clawState);
					wait1Msec(500);
					Rotate(180);
					claw=true;
					while(!SensorValue[touch]);
					gyroAngle=angle_old;
					nSyncedMotors = synchBC;
					nSyncedTurnRatio = -100;
					wait1Msec(100);
					}
			}
			ResetMotor(motorB);
			ResetMotor(motorC);
			wait1Msec(300);
		break;
	default:
		break;
	}
	while(true);
}
